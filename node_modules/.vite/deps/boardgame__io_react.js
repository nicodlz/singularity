import {
  Client,
  LobbyClient,
  MCTSBot,
  require_setImmediate
} from "./chunk-URW6FIQG.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  Local,
  SocketIO
} from "./chunk-PCDHHDGC.js";
import {
  require_rfc6902
} from "./chunk-HCE326LJ.js";
import {
  require_lodash
} from "./chunk-FQIH6FHC.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var pairSplitRegExp = /; */;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var pairs = str.split(pairSplitRegExp);
      var dec = opt.decode || decode;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var eq_idx = pair.indexOf("=");
        if (eq_idx < 0) {
          continue;
        }
        var key = pair.substr(0, eq_idx).trim();
        var val = pair.substr(++eq_idx, pair.length).trim();
        if ('"' == val[0]) {
          val = val.slice(1, -1);
        }
        if (void 0 == obj[key]) {
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge)) throw new Error("maxAge should be a Number");
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/react-cookies/build/cookie.js
var require_cookie2 = __commonJS({
  "node_modules/react-cookies/build/cookie.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    exports.load = load;
    exports.loadAll = loadAll;
    exports.select = select;
    exports.save = save;
    exports.remove = remove;
    exports.setRawCookie = setRawCookie;
    exports.plugToRequest = plugToRequest;
    var _cookie = require_cookie();
    var _cookie2 = _interopRequireDefault(_cookie);
    var _objectAssign = require_object_assign();
    var _objectAssign2 = _interopRequireDefault(_objectAssign);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IS_NODE = typeof document === "undefined" || typeof process !== "undefined" && process.env && false;
    var _rawCookie = {};
    var _res = void 0;
    function _isResWritable() {
      return _res && !_res.headersSent;
    }
    function load(name, doNotParse) {
      var cookies = IS_NODE ? _rawCookie : _cookie2.default.parse(document.cookie);
      var cookieVal = cookies && cookies[name];
      if (typeof doNotParse === "undefined") {
        doNotParse = !cookieVal || cookieVal[0] !== "{" && cookieVal[0] !== "[";
      }
      if (!doNotParse) {
        try {
          cookieVal = JSON.parse(cookieVal);
        } catch (err) {
        }
      }
      return cookieVal;
    }
    function loadAll(doNotParse) {
      var cookies = IS_NODE ? _rawCookie : _cookie2.default.parse(document.cookie);
      var cookieVal = cookies;
      if (typeof doNotParse === "undefined") {
        doNotParse = !cookieVal || cookieVal[0] !== "{" && cookieVal[0] !== "[";
      }
      if (!doNotParse) {
        try {
          cookieVal = JSON.parse(cookieVal);
        } catch (err) {
        }
      }
      return cookieVal;
    }
    function select(regex) {
      var cookies = IS_NODE ? _rawCookie : _cookie2.default.parse(document.cookie);
      if (!cookies) {
        return {};
      }
      if (!regex) {
        return cookies;
      }
      return Object.keys(cookies).reduce(function(accumulator, name) {
        if (!regex.test(name)) {
          return accumulator;
        }
        var newCookie = {};
        newCookie[name] = cookies[name];
        return (0, _objectAssign2.default)({}, accumulator, newCookie);
      }, {});
    }
    function save(name, val, opt) {
      _rawCookie[name] = val;
      if ((typeof val === "undefined" ? "undefined" : _typeof(val)) === "object") {
        _rawCookie[name] = JSON.stringify(val);
      }
      if (!IS_NODE) {
        document.cookie = _cookie2.default.serialize(name, _rawCookie[name], opt);
      }
      if (_isResWritable() && _res.cookie) {
        _res.cookie(name, val, opt);
      }
    }
    function remove(name, opt) {
      delete _rawCookie[name];
      if (typeof opt === "undefined") {
        opt = {};
      } else if (typeof opt === "string") {
        opt = { path: opt };
      } else {
        opt = (0, _objectAssign2.default)({}, opt);
      }
      if (typeof document !== "undefined") {
        opt.expires = new Date(1970, 1, 1, 0, 0, 1);
        opt.maxAge = 0;
        document.cookie = _cookie2.default.serialize(name, "", opt);
      }
      if (_isResWritable() && _res.clearCookie) {
        _res.clearCookie(name, opt);
      }
    }
    function setRawCookie(rawCookie) {
      if (rawCookie) {
        _rawCookie = _cookie2.default.parse(rawCookie);
      } else {
        _rawCookie = {};
      }
    }
    function plugToRequest(req, res) {
      if (req.cookie) {
        _rawCookie = req.cookie;
      } else if (req.cookies) {
        _rawCookie = req.cookies;
      } else if (req.headers && req.headers.cookie) {
        setRawCookie(req.headers.cookie);
      } else {
        _rawCookie = {};
      }
      _res = res;
      return function unplug() {
        _res = null;
        _rawCookie = {};
      };
    }
    exports.default = {
      setRawCookie,
      load,
      loadAll,
      select,
      save,
      remove,
      plugToRequest
    };
  }
});

// node_modules/boardgame.io/dist/esm/react.js
var import_lodash = __toESM(require_lodash());
var import_rfc6902 = __toESM(require_rfc6902());
var import_setimmediate = __toESM(require_setImmediate());
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_react_cookies = __toESM(require_cookie2());
function Client2(opts) {
  var _a;
  const { game, numPlayers, board, multiplayer, enhancer } = opts;
  let { loading, debug } = opts;
  if (loading === void 0) {
    const Loading = () => import_react.default.createElement("div", { className: "bgio-loading" }, "connecting...");
    loading = Loading;
  }
  return _a = class WrappedBoard extends import_react.default.Component {
    constructor(props) {
      super(props);
      if (debug === void 0) {
        debug = props.debug;
      }
      this.client = Client({
        game,
        debug,
        numPlayers,
        multiplayer,
        matchID: props.matchID,
        playerID: props.playerID,
        credentials: props.credentials,
        enhancer
      });
    }
    componentDidMount() {
      this.unsubscribe = this.client.subscribe(() => this.forceUpdate());
      this.client.start();
    }
    componentWillUnmount() {
      this.client.stop();
      this.unsubscribe();
    }
    componentDidUpdate(prevProps) {
      if (this.props.matchID != prevProps.matchID) {
        this.client.updateMatchID(this.props.matchID);
      }
      if (this.props.playerID != prevProps.playerID) {
        this.client.updatePlayerID(this.props.playerID);
      }
      if (this.props.credentials != prevProps.credentials) {
        this.client.updateCredentials(this.props.credentials);
      }
    }
    render() {
      const state = this.client.getState();
      if (state === null) {
        return import_react.default.createElement(loading);
      }
      let _board = null;
      if (board) {
        _board = import_react.default.createElement(board, {
          ...state,
          ...this.props,
          isMultiplayer: !!multiplayer,
          moves: this.client.moves,
          events: this.client.events,
          matchID: this.client.matchID,
          playerID: this.client.playerID,
          reset: this.client.reset,
          undo: this.client.undo,
          redo: this.client.redo,
          log: this.client.log,
          matchData: this.client.matchData,
          sendChatMessage: this.client.sendChatMessage,
          chatMessages: this.client.chatMessages
        });
      }
      return import_react.default.createElement("div", { className: "bgio-client" }, _board);
    }
  }, _a.propTypes = {
    // The ID of a game to connect to.
    // Only relevant in multiplayer.
    matchID: import_prop_types.default.string,
    // The ID of the player associated with this client.
    // Only relevant in multiplayer.
    playerID: import_prop_types.default.string,
    // This client's authentication credentials.
    // Only relevant in multiplayer.
    credentials: import_prop_types.default.string,
    // Enable / disable the Debug UI.
    debug: import_prop_types.default.any
  }, _a.defaultProps = {
    matchID: "default",
    playerID: null,
    credentials: null,
    debug: true
  }, _a;
}
var _LobbyConnectionImpl = class {
  constructor({ server, gameComponents, playerName, playerCredentials }) {
    this.client = new LobbyClient({ server });
    this.gameComponents = gameComponents;
    this.playerName = playerName || "Visitor";
    this.playerCredentials = playerCredentials;
    this.matches = [];
  }
  async refresh() {
    try {
      this.matches = [];
      const games = await this.client.listGames();
      for (const game of games) {
        if (!this._getGameComponents(game))
          continue;
        const { matches } = await this.client.listMatches(game);
        this.matches.push(...matches);
      }
    } catch (error) {
      throw new Error("failed to retrieve list of matches (" + error + ")");
    }
  }
  _getMatchInstance(matchID) {
    for (const inst of this.matches) {
      if (inst["matchID"] === matchID)
        return inst;
    }
  }
  _getGameComponents(gameName) {
    for (const comp of this.gameComponents) {
      if (comp.game.name === gameName)
        return comp;
    }
  }
  _findPlayer(playerName) {
    for (const inst of this.matches) {
      if (inst.players.some((player) => player.name === playerName))
        return inst;
    }
  }
  async join(gameName, matchID, playerID) {
    try {
      let inst = this._findPlayer(this.playerName);
      if (inst) {
        throw new Error("player has already joined " + inst.matchID);
      }
      inst = this._getMatchInstance(matchID);
      if (!inst) {
        throw new Error("game instance " + matchID + " not found");
      }
      const json = await this.client.joinMatch(gameName, matchID, {
        playerID,
        playerName: this.playerName
      });
      inst.players[Number.parseInt(playerID)].name = this.playerName;
      this.playerCredentials = json.playerCredentials;
    } catch (error) {
      throw new Error("failed to join match " + matchID + " (" + error + ")");
    }
  }
  async leave(gameName, matchID) {
    try {
      const inst = this._getMatchInstance(matchID);
      if (!inst)
        throw new Error("match instance not found");
      for (const player of inst.players) {
        if (player.name === this.playerName) {
          await this.client.leaveMatch(gameName, matchID, {
            playerID: player.id.toString(),
            credentials: this.playerCredentials
          });
          delete player.name;
          delete this.playerCredentials;
          return;
        }
      }
      throw new Error("player not found in match");
    } catch (error) {
      throw new Error("failed to leave match " + matchID + " (" + error + ")");
    }
  }
  async disconnect() {
    const inst = this._findPlayer(this.playerName);
    if (inst) {
      await this.leave(inst.gameName, inst.matchID);
    }
    this.matches = [];
    this.playerName = "Visitor";
  }
  async create(gameName, numPlayers) {
    try {
      const comp = this._getGameComponents(gameName);
      if (!comp)
        throw new Error("game not found");
      if (numPlayers < comp.game.minPlayers || numPlayers > comp.game.maxPlayers)
        throw new Error("invalid number of players " + numPlayers);
      await this.client.createMatch(gameName, { numPlayers });
    } catch (error) {
      throw new Error("failed to create match for " + gameName + " (" + error + ")");
    }
  }
};
function LobbyConnection(opts) {
  return new _LobbyConnectionImpl(opts);
}
var LobbyLoginForm = class extends import_react.default.Component {
  constructor() {
    super(...arguments);
    this.state = {
      playerName: this.props.playerName,
      nameErrorMsg: ""
    };
    this.onClickEnter = () => {
      if (this.state.playerName === "")
        return;
      this.props.onEnter(this.state.playerName);
    };
    this.onKeyPress = (event) => {
      if (event.key === "Enter") {
        this.onClickEnter();
      }
    };
    this.onChangePlayerName = (event) => {
      const name = event.target.value.trim();
      this.setState({
        playerName: name,
        nameErrorMsg: name.length > 0 ? "" : "empty player name"
      });
    };
  }
  render() {
    return import_react.default.createElement(
      "div",
      null,
      import_react.default.createElement("p", { className: "phase-title" }, "Choose a player name:"),
      import_react.default.createElement("input", { type: "text", value: this.state.playerName, onChange: this.onChangePlayerName, onKeyPress: this.onKeyPress }),
      import_react.default.createElement(
        "span",
        { className: "buttons" },
        import_react.default.createElement("button", { className: "buttons", onClick: this.onClickEnter }, "Enter")
      ),
      import_react.default.createElement("br", null),
      import_react.default.createElement(
        "span",
        { className: "error-msg" },
        this.state.nameErrorMsg,
        import_react.default.createElement("br", null)
      )
    );
  }
};
LobbyLoginForm.defaultProps = {
  playerName: ""
};
var LobbyMatchInstance = class extends import_react.default.Component {
  constructor() {
    super(...arguments);
    this._createSeat = (player) => {
      return player.name || "[free]";
    };
    this._createButtonJoin = (inst, seatId) => import_react.default.createElement("button", { key: "button-join-" + inst.matchID, onClick: () => this.props.onClickJoin(inst.gameName, inst.matchID, "" + seatId) }, "Join");
    this._createButtonLeave = (inst) => import_react.default.createElement("button", { key: "button-leave-" + inst.matchID, onClick: () => this.props.onClickLeave(inst.gameName, inst.matchID) }, "Leave");
    this._createButtonPlay = (inst, seatId) => import_react.default.createElement("button", { key: "button-play-" + inst.matchID, onClick: () => this.props.onClickPlay(inst.gameName, {
      matchID: inst.matchID,
      playerID: "" + seatId,
      numPlayers: inst.players.length
    }) }, "Play");
    this._createButtonSpectate = (inst) => import_react.default.createElement("button", { key: "button-spectate-" + inst.matchID, onClick: () => this.props.onClickPlay(inst.gameName, {
      matchID: inst.matchID,
      numPlayers: inst.players.length
    }) }, "Spectate");
    this._createInstanceButtons = (inst) => {
      const playerSeat = inst.players.find((player) => player.name === this.props.playerName);
      const freeSeat = inst.players.find((player) => !player.name);
      if (playerSeat && freeSeat) {
        return this._createButtonLeave(inst);
      }
      if (freeSeat) {
        return this._createButtonJoin(inst, freeSeat.id);
      }
      if (playerSeat) {
        return import_react.default.createElement("div", null, [
          this._createButtonPlay(inst, playerSeat.id),
          this._createButtonLeave(inst)
        ]);
      }
      return this._createButtonSpectate(inst);
    };
  }
  render() {
    const match = this.props.match;
    let status = "OPEN";
    if (!match.players.some((player) => !player.name)) {
      status = "RUNNING";
    }
    return import_react.default.createElement(
      "tr",
      { key: "line-" + match.matchID },
      import_react.default.createElement("td", { key: "cell-name-" + match.matchID }, match.gameName),
      import_react.default.createElement("td", { key: "cell-status-" + match.matchID }, status),
      import_react.default.createElement("td", { key: "cell-seats-" + match.matchID }, match.players.map((player) => this._createSeat(player)).join(", ")),
      import_react.default.createElement("td", { key: "cell-buttons-" + match.matchID }, this._createInstanceButtons(match))
    );
  }
};
var LobbyCreateMatchForm = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      selectedGame: 0,
      numPlayers: 2
    };
    this._createGameNameOption = (game, idx) => {
      return import_react.default.createElement("option", { key: "name-option-" + idx, value: idx }, game.game.name);
    };
    this._createNumPlayersOption = (idx) => {
      return import_react.default.createElement("option", { key: "num-option-" + idx, value: idx }, idx);
    };
    this._createNumPlayersRange = (game) => {
      return Array.from({ length: game.maxPlayers + 1 }).map((_, i) => i).slice(game.minPlayers);
    };
    this.onChangeNumPlayers = (event) => {
      this.setState({
        numPlayers: Number.parseInt(event.target.value)
      });
    };
    this.onChangeSelectedGame = (event) => {
      const idx = Number.parseInt(event.target.value);
      this.setState({
        selectedGame: idx,
        numPlayers: this.props.games[idx].game.minPlayers
      });
    };
    this.onClickCreate = () => {
      this.props.createMatch(this.props.games[this.state.selectedGame].game.name, this.state.numPlayers);
    };
    for (const game of props.games) {
      const matchDetails = game.game;
      if (!matchDetails.minPlayers) {
        matchDetails.minPlayers = 1;
      }
      if (!matchDetails.maxPlayers) {
        matchDetails.maxPlayers = 4;
      }
      console.assert(matchDetails.maxPlayers >= matchDetails.minPlayers);
    }
    this.state = {
      selectedGame: 0,
      numPlayers: props.games[0].game.minPlayers
    };
  }
  render() {
    return import_react.default.createElement(
      "div",
      null,
      import_react.default.createElement("select", { value: this.state.selectedGame, onChange: (evt) => this.onChangeSelectedGame(evt) }, this.props.games.map((game, index) => this._createGameNameOption(game, index))),
      import_react.default.createElement("span", null, "Players:"),
      import_react.default.createElement("select", { value: this.state.numPlayers, onChange: this.onChangeNumPlayers }, this._createNumPlayersRange(this.props.games[this.state.selectedGame].game).map((number) => this._createNumPlayersOption(number))),
      import_react.default.createElement(
        "span",
        { className: "buttons" },
        import_react.default.createElement("button", { onClick: this.onClickCreate }, "Create")
      )
    );
  }
};
var LobbyPhases;
(function(LobbyPhases2) {
  LobbyPhases2["ENTER"] = "enter";
  LobbyPhases2["PLAY"] = "play";
  LobbyPhases2["LIST"] = "list";
})(LobbyPhases || (LobbyPhases = {}));
var Lobby = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      phase: LobbyPhases.ENTER,
      playerName: "Visitor",
      runningMatch: null,
      errorMsg: "",
      credentialStore: {}
    };
    this._createConnection = (props2) => {
      const name = this.state.playerName;
      this.connection = LobbyConnection({
        server: props2.lobbyServer,
        gameComponents: props2.gameComponents,
        playerName: name,
        playerCredentials: this.state.credentialStore[name]
      });
    };
    this._updateCredentials = (playerName, credentials) => {
      this.setState((prevState) => {
        const store = Object.assign({}, prevState.credentialStore);
        store[playerName] = credentials;
        return { credentialStore: store };
      });
    };
    this._updateConnection = async () => {
      await this.connection.refresh();
      this.forceUpdate();
    };
    this._enterLobby = (playerName) => {
      this._startRefreshInterval();
      this.setState({ playerName, phase: LobbyPhases.LIST });
    };
    this._exitLobby = async () => {
      this._clearRefreshInterval();
      await this.connection.disconnect();
      this.setState({ phase: LobbyPhases.ENTER, errorMsg: "" });
    };
    this._createMatch = async (gameName, numPlayers) => {
      try {
        await this.connection.create(gameName, numPlayers);
        await this.connection.refresh();
        this.setState({});
      } catch (error) {
        this.setState({ errorMsg: error.message });
      }
    };
    this._joinMatch = async (gameName, matchID, playerID) => {
      try {
        await this.connection.join(gameName, matchID, playerID);
        await this.connection.refresh();
        this._updateCredentials(this.connection.playerName, this.connection.playerCredentials);
      } catch (error) {
        this.setState({ errorMsg: error.message });
      }
    };
    this._leaveMatch = async (gameName, matchID) => {
      try {
        await this.connection.leave(gameName, matchID);
        await this.connection.refresh();
        this._updateCredentials(this.connection.playerName, this.connection.playerCredentials);
      } catch (error) {
        this.setState({ errorMsg: error.message });
      }
    };
    this._startMatch = (gameName, matchOpts) => {
      const gameCode = this.connection._getGameComponents(gameName);
      if (!gameCode) {
        this.setState({
          errorMsg: "game " + gameName + " not supported"
        });
        return;
      }
      let multiplayer = void 0;
      if (matchOpts.numPlayers > 1) {
        multiplayer = this.props.gameServer ? SocketIO({ server: this.props.gameServer }) : SocketIO();
      }
      if (matchOpts.numPlayers == 1) {
        const maxPlayers = gameCode.game.maxPlayers;
        const bots = {};
        for (let i = 1; i < maxPlayers; i++) {
          bots[i + ""] = MCTSBot;
        }
        multiplayer = Local({ bots });
      }
      const app = this.props.clientFactory({
        game: gameCode.game,
        board: gameCode.board,
        debug: this.props.debug,
        multiplayer
      });
      const match = {
        app,
        matchID: matchOpts.matchID,
        playerID: matchOpts.numPlayers > 1 ? matchOpts.playerID : "0",
        credentials: this.connection.playerCredentials
      };
      this._clearRefreshInterval();
      this.setState({ phase: LobbyPhases.PLAY, runningMatch: match });
    };
    this._exitMatch = () => {
      this._startRefreshInterval();
      this.setState({ phase: LobbyPhases.LIST, runningMatch: null });
    };
    this._getPhaseVisibility = (phase) => {
      return this.state.phase !== phase ? "hidden" : "phase";
    };
    this.renderMatches = (matches, playerName) => {
      return matches.map((match) => {
        const { matchID, gameName, players } = match;
        return import_react.default.createElement(LobbyMatchInstance, { key: "instance-" + matchID, match: { matchID, gameName, players: Object.values(players) }, playerName, onClickJoin: this._joinMatch, onClickLeave: this._leaveMatch, onClickPlay: this._startMatch });
      });
    };
    this._createConnection(this.props);
  }
  componentDidMount() {
    const cookie = import_react_cookies.default.load("lobbyState") || {};
    if (cookie.phase && cookie.phase === LobbyPhases.PLAY) {
      cookie.phase = LobbyPhases.LIST;
    }
    if (cookie.phase && cookie.phase !== LobbyPhases.ENTER) {
      this._startRefreshInterval();
    }
    this.setState({
      phase: cookie.phase || LobbyPhases.ENTER,
      playerName: cookie.playerName || "Visitor",
      credentialStore: cookie.credentialStore || {}
    });
  }
  componentDidUpdate(prevProps, prevState) {
    const name = this.state.playerName;
    const creds = this.state.credentialStore[name];
    if (prevState.phase !== this.state.phase || prevState.credentialStore[name] !== creds || prevState.playerName !== name) {
      this._createConnection(this.props);
      this._updateConnection();
      const cookie = {
        phase: this.state.phase,
        playerName: name,
        credentialStore: this.state.credentialStore
      };
      import_react_cookies.default.save("lobbyState", cookie, { path: "/" });
    }
    if (prevProps.refreshInterval !== this.props.refreshInterval) {
      this._startRefreshInterval();
    }
  }
  componentWillUnmount() {
    this._clearRefreshInterval();
  }
  _startRefreshInterval() {
    this._clearRefreshInterval();
    this._currentInterval = setInterval(this._updateConnection, this.props.refreshInterval);
  }
  _clearRefreshInterval() {
    clearInterval(this._currentInterval);
  }
  render() {
    const { gameComponents, renderer } = this.props;
    const { errorMsg, playerName, phase, runningMatch } = this.state;
    if (renderer) {
      return renderer({
        errorMsg,
        gameComponents,
        matches: this.connection.matches,
        phase,
        playerName,
        runningMatch,
        handleEnterLobby: this._enterLobby,
        handleExitLobby: this._exitLobby,
        handleCreateMatch: this._createMatch,
        handleJoinMatch: this._joinMatch,
        handleLeaveMatch: this._leaveMatch,
        handleExitMatch: this._exitMatch,
        handleRefreshMatches: this._updateConnection,
        handleStartMatch: this._startMatch
      });
    }
    return import_react.default.createElement(
      "div",
      { id: "lobby-view", style: { padding: 50 } },
      import_react.default.createElement(
        "div",
        { className: this._getPhaseVisibility(LobbyPhases.ENTER) },
        import_react.default.createElement(LobbyLoginForm, { key: playerName, playerName, onEnter: this._enterLobby })
      ),
      import_react.default.createElement(
        "div",
        { className: this._getPhaseVisibility(LobbyPhases.LIST) },
        import_react.default.createElement(
          "p",
          null,
          "Welcome, ",
          playerName
        ),
        import_react.default.createElement(
          "div",
          { className: "phase-title", id: "match-creation" },
          import_react.default.createElement("span", null, "Create a match:"),
          import_react.default.createElement(LobbyCreateMatchForm, { games: gameComponents, createMatch: this._createMatch })
        ),
        import_react.default.createElement("p", { className: "phase-title" }, "Join a match:"),
        import_react.default.createElement(
          "div",
          { id: "instances" },
          import_react.default.createElement(
            "table",
            null,
            import_react.default.createElement("tbody", null, this.renderMatches(this.connection.matches, playerName))
          ),
          import_react.default.createElement(
            "span",
            { className: "error-msg" },
            errorMsg,
            import_react.default.createElement("br", null)
          )
        ),
        import_react.default.createElement("p", { className: "phase-title" }, "Matches that become empty are automatically deleted.")
      ),
      import_react.default.createElement(
        "div",
        { className: this._getPhaseVisibility(LobbyPhases.PLAY) },
        runningMatch && import_react.default.createElement(runningMatch.app, { matchID: runningMatch.matchID, playerID: runningMatch.playerID, credentials: runningMatch.credentials }),
        import_react.default.createElement(
          "div",
          { className: "buttons", id: "match-exit" },
          import_react.default.createElement("button", { onClick: this._exitMatch }, "Exit match")
        )
      ),
      import_react.default.createElement(
        "div",
        { className: "buttons", id: "lobby-exit" },
        import_react.default.createElement("button", { onClick: this._exitLobby }, "Exit lobby")
      )
    );
  }
};
Lobby.propTypes = {
  gameComponents: import_prop_types.default.array.isRequired,
  lobbyServer: import_prop_types.default.string,
  gameServer: import_prop_types.default.string,
  debug: import_prop_types.default.bool,
  clientFactory: import_prop_types.default.func,
  refreshInterval: import_prop_types.default.number
};
Lobby.defaultProps = {
  debug: false,
  clientFactory: Client2,
  refreshInterval: 2e3
};
export {
  Client2 as Client,
  Lobby
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=boardgame__io_react.js.map
