import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/lodash.isplainobject/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports, module) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject2(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject2;
  }
});

// node_modules/immer/dist/immer.esm.mjs
function n(n2) {
  for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e = 1; e < r2; e++) t2[e - 1] = arguments[e];
  if (true) {
    var i2 = Y[n2], o2 = i2 ? "function" == typeof i2 ? i2.apply(null, t2) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
  throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map((function(n3) {
    return "'" + n3 + "'";
  })).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n2) {
  return !!n2 && !!n2[Q];
}
function t(n2) {
  var r2;
  return !!n2 && ((function(n3) {
    if (!n3 || "object" != typeof n3) return false;
    var r3 = Object.getPrototypeOf(n3);
    if (null === r3) return true;
    var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
    return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z;
  })(n2) || Array.isArray(n2) || !!n2[L] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L]) || s(n2) || v(n2));
}
function i(n2, r2, t2) {
  void 0 === t2 && (t2 = false), 0 === o(n2) ? (t2 ? Object.keys : nn)(n2).forEach((function(e) {
    t2 && "symbol" == typeof e || r2(e, n2[e], n2);
  })) : n2.forEach((function(t3, e) {
    return r2(e, t3, n2);
  }));
}
function o(n2) {
  var r2 = n2[Q];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, r2) {
  return 2 === o(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a(n2, r2) {
  return 2 === o(n2) ? n2.get(r2) : n2[r2];
}
function f(n2, r2, t2) {
  var e = o(n2);
  2 === e ? n2.set(r2, t2) : 3 === e ? n2.add(t2) : n2[r2] = t2;
}
function c(n2, r2) {
  return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v(n2) {
  return q && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2)) return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q];
  for (var t2 = nn(r2), e = 0; e < t2.length; e++) {
    var i2 = t2[e], o2 = r2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d(n2, e) {
  return void 0 === e && (e = false), y(n2) || r(n2) || !t(n2) || (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e && i(n2, (function(n3, r2) {
    return d(r2, true);
  }), true)), n2;
}
function h() {
  n(2);
}
function y(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b(r2) {
  var t2 = tn[r2];
  return t2 || n(18, r2), t2;
}
function _() {
  return U || n(0), U;
}
function j(n2, r2) {
  r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function g(n2) {
  O(n2), n2.p.forEach(S), n2.p = null;
}
function O(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S(n2) {
  var r2 = n2[Q];
  0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
}
function P(r2, e) {
  e._ = e.p.length;
  var i2 = e.p[0], o2 = void 0 !== r2 && r2 !== i2;
  return e.h.O || b("ES5").S(e, r2, o2), o2 ? (i2[Q].P && (g(e), n(4)), t(r2) && (r2 = M(e, r2), e.l || x(e, r2)), e.u && b("Patches").M(i2[Q].t, r2, e.u, e.s)) : r2 = M(e, i2, []), g(e), e.u && e.v(e.u, e.s), r2 !== H ? r2 : void 0;
}
function M(n2, r2, t2) {
  if (y(r2)) return r2;
  var e = r2[Q];
  if (!e) return i(r2, (function(i2, o3) {
    return A(n2, e, r2, i2, o3, t2);
  }), true), r2;
  if (e.A !== n2) return r2;
  if (!e.P) return x(n2, e.t, true), e.t;
  if (!e.I) {
    e.I = true, e.A._--;
    var o2 = 4 === e.i || 5 === e.i ? e.o = l(e.k) : e.o, u2 = o2, a2 = false;
    3 === e.i && (u2 = new Set(o2), o2.clear(), a2 = true), i(u2, (function(r3, i2) {
      return A(n2, e, o2, r3, i2, t2, a2);
    })), x(n2, o2, false), t2 && n2.u && b("Patches").N(e, t2, n2.u, n2.s);
  }
  return e.o;
}
function A(e, i2, o2, a2, c2, s2, v2) {
  if (c2 === o2 && n(5), r(c2)) {
    var p2 = M(e, c2, s2 && i2 && 3 !== i2.i && !u(i2.R, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, p2), !r(p2)) return;
    e.m = false;
  } else v2 && o2.add(c2);
  if (t(c2) && !y(c2)) {
    if (!e.h.D && e._ < 1) return;
    M(e, c2), i2 && i2.A.l || x(e, c2);
  }
}
function x(n2, r2, t2) {
  void 0 === t2 && (t2 = false), !n2.l && n2.h.D && n2.m && d(r2, t2);
}
function z(n2, r2) {
  var t2 = n2[Q];
  return (t2 ? p(t2) : n2)[r2];
}
function I(n2, r2) {
  if (r2 in n2) for (var t2 = Object.getPrototypeOf(n2); t2; ) {
    var e = Object.getOwnPropertyDescriptor(t2, r2);
    if (e) return e;
    t2 = Object.getPrototypeOf(t2);
  }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function N(n2, r2, t2) {
  var e = s(r2) ? b("MapSet").F(r2, t2) : v(r2) ? b("MapSet").T(r2, t2) : n2.O ? (function(n3, r3) {
    var t3 = Array.isArray(n3), e2 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e2, o2 = en;
    t3 && (i2 = [e2], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e2.k = f2, e2.j = a2, f2;
  })(r2, t2) : b("ES5").J(r2, t2);
  return (t2 ? t2.A : _()).p.push(e), e;
}
function R(e) {
  return r(e) || n(22, e), (function n2(r2) {
    if (!t(r2)) return r2;
    var e2, u2 = r2[Q], c2 = o(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2))) return u2.t;
      u2.I = true, e2 = D(r2, c2), u2.I = false;
    } else e2 = D(r2, c2);
    return i(e2, (function(r3, t2) {
      u2 && a(u2.t, r3) === t2 || f(e2, r3, n2(t2));
    })), 3 === c2 ? new Set(e2) : e2;
  })(e);
}
function D(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n2) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n2) {
  return "Cannot apply patch, path doesn't resolve: " + n2;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n2) {
  return "Unsupported patch operation: " + n2;
}, 18: function(n2) {
  return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n2) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
}, 22: function(n2) {
  return "'current' expects a draft, got: " + n2;
}, 23: function(n2) {
  return "'original' expects a draft, got: " + n2;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach((function(t2) {
    r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
  })), r2;
};
var tn = {};
var en = { get: function(n2, r2) {
  if (r2 === Q) return n2;
  var e = p(n2);
  if (!u(e, r2)) return (function(n3, r3, t2) {
    var e2, i3 = I(r3, t2);
    return i3 ? "value" in i3 ? i3.value : null === (e2 = i3.get) || void 0 === e2 ? void 0 : e2.call(n3.k) : void 0;
  })(n2, e, r2);
  var i2 = e[r2];
  return n2.I || !t(i2) ? i2 : i2 === z(n2.t, r2) ? (E(n2), n2.o[r2] = N(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, r2, t2) {
  var e = I(p(n2), r2);
  if (null == e ? void 0 : e.set) return e.set.call(n2.k, t2), true;
  if (!n2.P) {
    var i2 = z(p(n2), r2), o2 = null == i2 ? void 0 : i2[Q];
    if (o2 && o2.t === t2) return n2.o[r2] = t2, n2.R[r2] = false, true;
    if (c(t2, i2) && (void 0 !== t2 || u(n2.t, r2))) return true;
    E(n2), k(n2);
  }
  return n2.o[r2] === t2 && (void 0 !== t2 || r2 in n2.o) || Number.isNaN(t2) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t2, n2.R[r2] = true), true;
}, deleteProperty: function(n2, r2) {
  return void 0 !== z(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E(n2), k(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t2 = p(n2), e = Reflect.getOwnPropertyDescriptor(t2, r2);
  return e ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e.enumerable, value: t2[r2] } : e;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, (function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
})), on.deleteProperty = function(r2, t2) {
  return isNaN(parseInt(t2)) && n(13), on.set.call(this, r2, t2, void 0);
}, on.set = function(r2, t2, e) {
  return "length" !== t2 && isNaN(parseInt(t2)) && n(14), en.set.call(this, r2[0], t2, e, r2[0]);
};
var un = (function() {
  function e(r2) {
    var e2 = this;
    this.O = B, this.D = true, this.produce = function(r3, i3, o2) {
      if ("function" == typeof r3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = r3;
        var a2 = e2;
        return function(n2) {
          var r4 = this;
          void 0 === n2 && (n2 = u2);
          for (var t2 = arguments.length, e3 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++) e3[o3 - 1] = arguments[o3];
          return a2.produce(n2, (function(n3) {
            var t3;
            return (t3 = i3).call.apply(t3, [r4, n3].concat(e3));
          }));
        };
      }
      var f2;
      if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), t(r3)) {
        var c2 = w(e2), s2 = N(e2, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? g(c2) : O(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then((function(n2) {
          return j(c2, o2), P(n2, c2);
        }), (function(n2) {
          throw g(c2), n2;
        })) : (j(c2, o2), P(f2, c2));
      }
      if (!r3 || "object" != typeof r3) {
        if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H && (f2 = void 0), e2.D && d(f2, true), o2) {
          var p2 = [], l2 = [];
          b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if ("function" == typeof n2) return function(r4) {
        for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++) i4[o3 - 1] = arguments[o3];
        return e2.produceWithPatches(r4, (function(r5) {
          return n2.apply(void 0, [r5].concat(i4));
        }));
      };
      var t2, i3, o2 = e2.produce(n2, r3, (function(n3, r4) {
        t2 = n3, i3 = r4;
      }));
      return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then((function(n3) {
        return [n3, t2, i3];
      })) : [o2, t2, i3];
    }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e.prototype;
  return i2.createDraft = function(e2) {
    t(e2) || n(8), r(e2) && (e2 = R(e2));
    var i3 = w(this), o2 = N(this, e2, void 0);
    return o2[Q].C = true, O(i3), o2;
  }, i2.finishDraft = function(r2, t2) {
    var e2 = r2 && r2[Q];
    e2 && e2.C || n(9), e2.I && n(10);
    var i3 = e2.A;
    return j(i3, t2), P(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.D = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B && n(20), this.O = r2;
  }, i2.applyPatches = function(n2, t2) {
    var e2;
    for (e2 = t2.length - 1; e2 >= 0; e2--) {
      var i3 = t2[e2];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e2 > -1 && (t2 = t2.slice(e2 + 1));
    var o2 = b("Patches").$;
    return r(n2) ? o2(n2, t2) : this.produce(n2, (function(n3) {
      return o2(n3, t2);
    }));
  }, e;
})();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);
var immer_esm_default = fn;

// node_modules/boardgame.io/dist/esm/plugin-random-087f861e.js
var Alea = class {
  constructor(seed) {
    const mash = Mash();
    this.c = 1;
    this.s0 = mash(" ");
    this.s1 = mash(" ");
    this.s2 = mash(" ");
    this.s0 -= mash(seed);
    if (this.s0 < 0) {
      this.s0 += 1;
    }
    this.s1 -= mash(seed);
    if (this.s1 < 0) {
      this.s1 += 1;
    }
    this.s2 -= mash(seed);
    if (this.s2 < 0) {
      this.s2 += 1;
    }
  }
  next() {
    const t2 = 2091639 * this.s0 + this.c * 23283064365386963e-26;
    this.s0 = this.s1;
    this.s1 = this.s2;
    return this.s2 = t2 - (this.c = Math.trunc(t2));
  }
};
function Mash() {
  let n2 = 4022871197;
  const mash = function(data) {
    const str = data.toString();
    for (let i2 = 0; i2 < str.length; i2++) {
      n2 += str.charCodeAt(i2);
      let h2 = 0.02519603282416938 * n2;
      n2 = h2 >>> 0;
      h2 -= n2;
      h2 *= n2;
      n2 = h2 >>> 0;
      h2 -= n2;
      n2 += h2 * 4294967296;
    }
    return (n2 >>> 0) * 23283064365386963e-26;
  };
  return mash;
}
function copy(f2, t2) {
  t2.c = f2.c;
  t2.s0 = f2.s0;
  t2.s1 = f2.s1;
  t2.s2 = f2.s2;
  return t2;
}
function alea(seed, state) {
  const xg = new Alea(seed);
  const prng = xg.next.bind(xg);
  if (state)
    copy(state, xg);
  prng.state = () => copy(xg, {});
  return prng;
}
var Random = class {
  /**
   * constructor
   * @param {object} ctx - The ctx object to initialize from.
   */
  constructor(state) {
    this.state = state || { seed: "0" };
    this.used = false;
  }
  /**
   * Generates a new seed from the current date / time.
   */
  static seed() {
    return Date.now().toString(36).slice(-10);
  }
  isUsed() {
    return this.used;
  }
  getState() {
    return this.state;
  }
  /**
   * Generate a random number.
   */
  _random() {
    this.used = true;
    const R2 = this.state;
    const seed = R2.prngstate ? "" : R2.seed;
    const rand = alea(seed, R2.prngstate);
    const number = rand();
    this.state = {
      ...R2,
      prngstate: rand.state()
    };
    return number;
  }
  api() {
    const random = this._random.bind(this);
    const SpotValue = {
      D4: 4,
      D6: 6,
      D8: 8,
      D10: 10,
      D12: 12,
      D20: 20
    };
    const predefined = {};
    for (const key in SpotValue) {
      const spotvalue = SpotValue[key];
      predefined[key] = (diceCount) => {
        return diceCount === void 0 ? Math.floor(random() * spotvalue) + 1 : Array.from({ length: diceCount }).map(() => Math.floor(random() * spotvalue) + 1);
      };
    }
    function Die(spotvalue = 6, diceCount) {
      return diceCount === void 0 ? Math.floor(random() * spotvalue) + 1 : Array.from({ length: diceCount }).map(() => Math.floor(random() * spotvalue) + 1);
    }
    return {
      /**
       * Similar to Die below, but with fixed spot values.
       * Supports passing a diceCount
       *    if not defined, defaults to 1 and returns the value directly.
       *    if defined, returns an array containing the random dice values.
       *
       * D4: (diceCount) => value
       * D6: (diceCount) => value
       * D8: (diceCount) => value
       * D10: (diceCount) => value
       * D12: (diceCount) => value
       * D20: (diceCount) => value
       */
      ...predefined,
      /**
       * Roll a die of specified spot value.
       *
       * @param {number} spotvalue - The die dimension (default: 6).
       * @param {number} diceCount - number of dice to throw.
       *                             if not defined, defaults to 1 and returns the value directly.
       *                             if defined, returns an array containing the random dice values.
       */
      Die,
      /**
       * Generate a random number between 0 and 1.
       */
      Number: () => {
        return random();
      },
      /**
       * Shuffle an array.
       *
       * @param {Array} deck - The array to shuffle. Does not mutate
       *                       the input, but returns the shuffled array.
       */
      Shuffle: (deck) => {
        const clone = [...deck];
        let sourceIndex = deck.length;
        let destinationIndex = 0;
        const shuffled = Array.from({ length: sourceIndex });
        while (sourceIndex) {
          const randomIndex = Math.trunc(sourceIndex * random());
          shuffled[destinationIndex++] = clone[randomIndex];
          clone[randomIndex] = clone[--sourceIndex];
        }
        return shuffled;
      },
      _private: this
    };
  }
};
var RandomPlugin = {
  name: "random",
  noClient: ({ api }) => {
    return api._private.isUsed();
  },
  flush: ({ api }) => {
    return api._private.getState();
  },
  api: ({ data }) => {
    const random = new Random(data);
    return random.api();
  },
  setup: ({ game }) => {
    let { seed } = game;
    if (seed === void 0) {
      seed = Random.seed();
    }
    return { seed };
  },
  playerView: () => void 0
};

// node_modules/boardgame.io/dist/esm/turn-order-8cc4909b.js
var import_lodash = __toESM(require_lodash());
var MAKE_MOVE = "MAKE_MOVE";
var GAME_EVENT = "GAME_EVENT";
var REDO = "REDO";
var RESET = "RESET";
var SYNC = "SYNC";
var UNDO = "UNDO";
var UPDATE = "UPDATE";
var PATCH = "PATCH";
var PLUGIN = "PLUGIN";
var STRIP_TRANSIENTS = "STRIP_TRANSIENTS";
var makeMove = (type, args, playerID, credentials) => ({
  type: MAKE_MOVE,
  payload: { type, args, playerID, credentials }
});
var gameEvent = (type, args, playerID, credentials) => ({
  type: GAME_EVENT,
  payload: { type, args, playerID, credentials }
});
var automaticGameEvent = (type, args, playerID, credentials) => ({
  type: GAME_EVENT,
  payload: { type, args, playerID, credentials },
  automatic: true
});
var sync = (info2) => ({
  type: SYNC,
  state: info2.state,
  log: info2.log,
  initialState: info2.initialState,
  clientOnly: true
});
var patch = (prevStateID, stateID, patch2, deltalog) => ({
  type: PATCH,
  prevStateID,
  stateID,
  patch: patch2,
  deltalog,
  clientOnly: true
});
var update = (state, deltalog) => ({
  type: UPDATE,
  state,
  deltalog,
  clientOnly: true
});
var reset = (state) => ({
  type: RESET,
  state,
  clientOnly: true
});
var undo = (playerID, credentials) => ({
  type: UNDO,
  payload: { type: null, args: null, playerID, credentials }
});
var redo = (playerID, credentials) => ({
  type: REDO,
  payload: { type: null, args: null, playerID, credentials }
});
var plugin = (type, args, playerID, credentials) => ({
  type: PLUGIN,
  payload: { type, args, playerID, credentials }
});
var stripTransients = () => ({
  type: STRIP_TRANSIENTS
});
var ActionCreators = Object.freeze({
  __proto__: null,
  makeMove,
  gameEvent,
  automaticGameEvent,
  sync,
  patch,
  update,
  reset,
  undo,
  redo,
  plugin,
  stripTransients
});
var INVALID_MOVE = "INVALID_MOVE";
var ImmerPlugin = {
  name: "plugin-immer",
  fnWrap: (move) => (context, ...args) => {
    let isInvalid = false;
    const newG = immer_esm_default(context.G, (G2) => {
      const result = move({ ...context, G: G2 }, ...args);
      if (result === INVALID_MOVE) {
        isInvalid = true;
        return;
      }
      return result;
    });
    if (isInvalid)
      return INVALID_MOVE;
    return newG;
  }
};
var GameMethod;
(function(GameMethod2) {
  GameMethod2["MOVE"] = "MOVE";
  GameMethod2["GAME_ON_END"] = "GAME_ON_END";
  GameMethod2["PHASE_ON_BEGIN"] = "PHASE_ON_BEGIN";
  GameMethod2["PHASE_ON_END"] = "PHASE_ON_END";
  GameMethod2["TURN_ON_BEGIN"] = "TURN_ON_BEGIN";
  GameMethod2["TURN_ON_MOVE"] = "TURN_ON_MOVE";
  GameMethod2["TURN_ON_END"] = "TURN_ON_END";
})(GameMethod || (GameMethod = {}));
var Errors;
(function(Errors2) {
  Errors2["CalledOutsideHook"] = "Events must be called from moves or the `onBegin`, `onEnd`, and `onMove` hooks.\nThis error probably means you called an event from other game code, like an `endIf` trigger or one of the `turn.order` methods.";
  Errors2["EndTurnInOnEnd"] = "`endTurn` is disallowed in `onEnd` hooks — the turn is already ending.";
  Errors2["MaxTurnEndings"] = "Maximum number of turn endings exceeded for this update.\nThis likely means game code is triggering an infinite loop.";
  Errors2["PhaseEventInOnEnd"] = "`setPhase` & `endPhase` are disallowed in a phase’s `onEnd` hook — the phase is already ending.\nIf you’re trying to dynamically choose the next phase when a phase ends, use the phase’s `next` trigger.";
  Errors2["StageEventInOnEnd"] = "`setStage`, `endStage` & `setActivePlayers` are disallowed in `onEnd` hooks.";
  Errors2["StageEventInPhaseBegin"] = "`setStage`, `endStage` & `setActivePlayers` are disallowed in a phase’s `onBegin` hook.\nUse `setActivePlayers` in a `turn.onBegin` hook or declare stages with `turn.activePlayers` instead.";
  Errors2["StageEventInTurnBegin"] = "`setStage` & `endStage` are disallowed in `turn.onBegin`.\nUse `setActivePlayers` or declare stages with `turn.activePlayers` instead.";
})(Errors || (Errors = {}));
var Events = class {
  constructor(flow, ctx, playerID) {
    this.flow = flow;
    this.playerID = playerID;
    this.dispatch = [];
    this.initialTurn = ctx.turn;
    this.updateTurnContext(ctx, void 0);
    this.maxEndedTurnsPerAction = ctx.numPlayers * 100;
  }
  api() {
    const events = {
      _private: this
    };
    for (const type of this.flow.eventNames) {
      events[type] = (...args) => {
        this.dispatch.push({
          type,
          args,
          phase: this.currentPhase,
          turn: this.currentTurn,
          calledFrom: this.currentMethod,
          // Used to capture a stack trace in case it is needed later.
          error: new Error("Events Plugin Error")
        });
      };
    }
    return events;
  }
  isUsed() {
    return this.dispatch.length > 0;
  }
  updateTurnContext(ctx, methodType) {
    this.currentPhase = ctx.phase;
    this.currentTurn = ctx.turn;
    this.currentMethod = methodType;
  }
  unsetCurrentMethod() {
    this.currentMethod = void 0;
  }
  /**
   * Updates ctx with the triggered events.
   * @param {object} state - The state object { G, ctx }.
   */
  update(state) {
    const initialState = state;
    const stateWithError = ({ stack }, message) => ({
      ...initialState,
      plugins: {
        ...initialState.plugins,
        events: {
          ...initialState.plugins.events,
          data: { error: message + "\n" + stack }
        }
      }
    });
    EventQueue: for (let i2 = 0; i2 < this.dispatch.length; i2++) {
      const event = this.dispatch[i2];
      const turnHasEnded = event.turn !== state.ctx.turn;
      const endedTurns = this.currentTurn - this.initialTurn;
      if (endedTurns >= this.maxEndedTurnsPerAction) {
        return stateWithError(event.error, Errors.MaxTurnEndings);
      }
      if (event.calledFrom === void 0) {
        return stateWithError(event.error, Errors.CalledOutsideHook);
      }
      if (state.ctx.gameover)
        break EventQueue;
      switch (event.type) {
        case "endStage":
        case "setStage":
        case "setActivePlayers": {
          switch (event.calledFrom) {
            // Disallow all stage events in onEnd and phase.onBegin hooks.
            case GameMethod.TURN_ON_END:
            case GameMethod.PHASE_ON_END:
              return stateWithError(event.error, Errors.StageEventInOnEnd);
            case GameMethod.PHASE_ON_BEGIN:
              return stateWithError(event.error, Errors.StageEventInPhaseBegin);
            // Disallow setStage & endStage in turn.onBegin hooks.
            case GameMethod.TURN_ON_BEGIN:
              if (event.type === "setActivePlayers")
                break;
              return stateWithError(event.error, Errors.StageEventInTurnBegin);
          }
          if (turnHasEnded)
            continue EventQueue;
          break;
        }
        case "endTurn": {
          if (event.calledFrom === GameMethod.TURN_ON_END || event.calledFrom === GameMethod.PHASE_ON_END) {
            return stateWithError(event.error, Errors.EndTurnInOnEnd);
          }
          if (turnHasEnded)
            continue EventQueue;
          break;
        }
        case "endPhase":
        case "setPhase": {
          if (event.calledFrom === GameMethod.PHASE_ON_END) {
            return stateWithError(event.error, Errors.PhaseEventInOnEnd);
          }
          if (event.phase !== state.ctx.phase)
            continue EventQueue;
          break;
        }
      }
      const action = automaticGameEvent(event.type, event.args, this.playerID);
      state = this.flow.processEvent(state, action);
    }
    return state;
  }
};
var EventsPlugin = {
  name: "events",
  noClient: ({ api }) => api._private.isUsed(),
  isInvalid: ({ data }) => data.error || false,
  // Update the events plugin’s internal turn context each time a move
  // or hook is called. This allows events called after turn or phase
  // endings to dispatch the current turn and phase correctly.
  fnWrap: (method, methodType) => (context, ...args) => {
    const api = context.events;
    if (api)
      api._private.updateTurnContext(context.ctx, methodType);
    const G2 = method(context, ...args);
    if (api)
      api._private.unsetCurrentMethod();
    return G2;
  },
  dangerouslyFlushRawState: ({ state, api }) => api._private.update(state),
  api: ({ game, ctx, playerID }) => new Events(game.flow, ctx, playerID).api()
};
var LogPlugin = {
  name: "log",
  flush: () => ({}),
  api: ({ data }) => {
    return {
      setMetadata: (metadata) => {
        data.metadata = metadata;
      }
    };
  },
  setup: () => ({})
};
function isSerializable(value) {
  if (value === void 0 || value === null || typeof value === "boolean" || typeof value === "number" || typeof value === "string") {
    return true;
  }
  if (!(0, import_lodash.default)(value) && !Array.isArray(value)) {
    return false;
  }
  for (const key in value) {
    if (!isSerializable(value[key]))
      return false;
  }
  return true;
}
var SerializablePlugin = {
  name: "plugin-serializable",
  fnWrap: (move) => (context, ...args) => {
    const result = move(context, ...args);
    if (!isSerializable(result)) {
      throw new Error("Move state is not JSON-serialiazable.\nSee https://boardgame.io/documentation/#/?id=state for more information.");
    }
    return result;
  }
};
var production = false;
var logfn = production ? () => {
} : (...msg) => console.log(...msg);
var errorfn = (...msg) => console.error(...msg);
function info(msg) {
  logfn(`INFO: ${msg}`);
}
function error(error2) {
  errorfn("ERROR:", error2);
}
var CORE_PLUGINS = [ImmerPlugin, RandomPlugin, LogPlugin, SerializablePlugin];
var DEFAULT_PLUGINS = [...CORE_PLUGINS, EventsPlugin];
var ProcessAction = (state, action, opts) => {
  opts.game.plugins.filter((plugin2) => plugin2.action !== void 0).filter((plugin2) => plugin2.name === action.payload.type).forEach((plugin2) => {
    const name = plugin2.name;
    const pluginState = state.plugins[name] || { data: {} };
    const data = plugin2.action(pluginState.data, action.payload);
    state = {
      ...state,
      plugins: {
        ...state.plugins,
        [name]: { ...pluginState, data }
      }
    };
  });
  return state;
};
var GetAPIs = ({ plugins }) => Object.entries(plugins || {}).reduce((apis, [name, { api }]) => {
  apis[name] = api;
  return apis;
}, {});
var FnWrap = (methodToWrap, methodType, plugins) => {
  return [...CORE_PLUGINS, ...plugins, EventsPlugin].filter((plugin2) => plugin2.fnWrap !== void 0).reduce((method, { fnWrap }) => fnWrap(method, methodType), methodToWrap);
};
var Setup = (state, opts) => {
  [...DEFAULT_PLUGINS, ...opts.game.plugins].filter((plugin2) => plugin2.setup !== void 0).forEach((plugin2) => {
    const name = plugin2.name;
    const data = plugin2.setup({
      G: state.G,
      ctx: state.ctx,
      game: opts.game
    });
    state = {
      ...state,
      plugins: {
        ...state.plugins,
        [name]: { data }
      }
    };
  });
  return state;
};
var Enhance = (state, opts) => {
  [...DEFAULT_PLUGINS, ...opts.game.plugins].filter((plugin2) => plugin2.api !== void 0).forEach((plugin2) => {
    const name = plugin2.name;
    const pluginState = state.plugins[name] || { data: {} };
    const api = plugin2.api({
      G: state.G,
      ctx: state.ctx,
      data: pluginState.data,
      game: opts.game,
      playerID: opts.playerID
    });
    state = {
      ...state,
      plugins: {
        ...state.plugins,
        [name]: { ...pluginState, api }
      }
    };
  });
  return state;
};
var Flush = (state, opts) => {
  [...CORE_PLUGINS, ...opts.game.plugins, EventsPlugin].reverse().forEach((plugin2) => {
    const name = plugin2.name;
    const pluginState = state.plugins[name] || { data: {} };
    if (plugin2.flush) {
      const newData = plugin2.flush({
        G: state.G,
        ctx: state.ctx,
        game: opts.game,
        api: pluginState.api,
        data: pluginState.data
      });
      state = {
        ...state,
        plugins: {
          ...state.plugins,
          [plugin2.name]: { data: newData }
        }
      };
    } else if (plugin2.dangerouslyFlushRawState) {
      state = plugin2.dangerouslyFlushRawState({
        state,
        game: opts.game,
        api: pluginState.api,
        data: pluginState.data
      });
      const data = state.plugins[name].data;
      state = {
        ...state,
        plugins: {
          ...state.plugins,
          [plugin2.name]: { data }
        }
      };
    }
  });
  return state;
};
var NoClient = (state, opts) => {
  return [...DEFAULT_PLUGINS, ...opts.game.plugins].filter((plugin2) => plugin2.noClient !== void 0).map((plugin2) => {
    const name = plugin2.name;
    const pluginState = state.plugins[name];
    if (pluginState) {
      return plugin2.noClient({
        G: state.G,
        ctx: state.ctx,
        game: opts.game,
        api: pluginState.api,
        data: pluginState.data
      });
    }
    return false;
  }).includes(true);
};
var IsInvalid = (state, opts) => {
  const firstInvalidReturn = [...DEFAULT_PLUGINS, ...opts.game.plugins].filter((plugin2) => plugin2.isInvalid !== void 0).map((plugin2) => {
    const { name } = plugin2;
    const pluginState = state.plugins[name];
    const message = plugin2.isInvalid({
      G: state.G,
      ctx: state.ctx,
      game: opts.game,
      data: pluginState && pluginState.data
    });
    return message ? { plugin: name, message } : false;
  }).find((value) => value);
  return firstInvalidReturn || false;
};
var FlushAndValidate = (state, opts) => {
  const updatedState = Flush(state, opts);
  const isInvalid = IsInvalid(updatedState, opts);
  if (!isInvalid)
    return [updatedState];
  const { plugin: plugin2, message } = isInvalid;
  error(`${plugin2} plugin declared action invalid:
${message}`);
  return [state, isInvalid];
};
var PlayerView = ({ G: G2, ctx, plugins = {} }, { game, playerID }) => {
  [...DEFAULT_PLUGINS, ...game.plugins].forEach(({ name, playerView }) => {
    if (!playerView)
      return;
    const { data } = plugins[name] || { data: {} };
    const newData = playerView({ G: G2, ctx, game, data, playerID });
    plugins = {
      ...plugins,
      [name]: { data: newData }
    };
  });
  return plugins;
};
function supportDeprecatedMoveLimit(options, enforceMinMoves = false) {
  if (options.moveLimit) {
    if (enforceMinMoves) {
      options.minMoves = options.moveLimit;
    }
    options.maxMoves = options.moveLimit;
    delete options.moveLimit;
  }
}
function SetActivePlayers(ctx, arg) {
  let activePlayers = {};
  let _prevActivePlayers = [];
  let _nextActivePlayers = null;
  let _activePlayersMinMoves = {};
  let _activePlayersMaxMoves = {};
  if (Array.isArray(arg)) {
    const value = {};
    arg.forEach((v2) => value[v2] = Stage.NULL);
    activePlayers = value;
  } else {
    supportDeprecatedMoveLimit(arg);
    if (arg.next) {
      _nextActivePlayers = arg.next;
    }
    if (arg.revert) {
      _prevActivePlayers = [
        ...ctx._prevActivePlayers,
        {
          activePlayers: ctx.activePlayers,
          _activePlayersMinMoves: ctx._activePlayersMinMoves,
          _activePlayersMaxMoves: ctx._activePlayersMaxMoves,
          _activePlayersNumMoves: ctx._activePlayersNumMoves
        }
      ];
    }
    if (arg.currentPlayer !== void 0) {
      ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, ctx.currentPlayer, arg.currentPlayer);
    }
    if (arg.others !== void 0) {
      for (let i2 = 0; i2 < ctx.playOrder.length; i2++) {
        const id = ctx.playOrder[i2];
        if (id !== ctx.currentPlayer) {
          ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, id, arg.others);
        }
      }
    }
    if (arg.all !== void 0) {
      for (let i2 = 0; i2 < ctx.playOrder.length; i2++) {
        const id = ctx.playOrder[i2];
        ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, id, arg.all);
      }
    }
    if (arg.value) {
      for (const id in arg.value) {
        ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, id, arg.value[id]);
      }
    }
    if (arg.minMoves) {
      for (const id in activePlayers) {
        if (_activePlayersMinMoves[id] === void 0) {
          _activePlayersMinMoves[id] = arg.minMoves;
        }
      }
    }
    if (arg.maxMoves) {
      for (const id in activePlayers) {
        if (_activePlayersMaxMoves[id] === void 0) {
          _activePlayersMaxMoves[id] = arg.maxMoves;
        }
      }
    }
  }
  if (Object.keys(activePlayers).length === 0) {
    activePlayers = null;
  }
  if (Object.keys(_activePlayersMinMoves).length === 0) {
    _activePlayersMinMoves = null;
  }
  if (Object.keys(_activePlayersMaxMoves).length === 0) {
    _activePlayersMaxMoves = null;
  }
  const _activePlayersNumMoves = {};
  for (const id in activePlayers) {
    _activePlayersNumMoves[id] = 0;
  }
  return {
    ...ctx,
    activePlayers,
    _activePlayersMinMoves,
    _activePlayersMaxMoves,
    _activePlayersNumMoves,
    _prevActivePlayers,
    _nextActivePlayers
  };
}
function UpdateActivePlayersOnceEmpty(ctx) {
  let { activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, _activePlayersNumMoves, _prevActivePlayers, _nextActivePlayers } = ctx;
  if (activePlayers && Object.keys(activePlayers).length === 0) {
    if (_nextActivePlayers) {
      ctx = SetActivePlayers(ctx, _nextActivePlayers);
      ({
        activePlayers,
        _activePlayersMinMoves,
        _activePlayersMaxMoves,
        _activePlayersNumMoves,
        _prevActivePlayers
      } = ctx);
    } else if (_prevActivePlayers.length > 0) {
      const lastIndex = _prevActivePlayers.length - 1;
      ({
        activePlayers,
        _activePlayersMinMoves,
        _activePlayersMaxMoves,
        _activePlayersNumMoves
      } = _prevActivePlayers[lastIndex]);
      _prevActivePlayers = _prevActivePlayers.slice(0, lastIndex);
    } else {
      activePlayers = null;
      _activePlayersMinMoves = null;
      _activePlayersMaxMoves = null;
    }
  }
  return {
    ...ctx,
    activePlayers,
    _activePlayersMinMoves,
    _activePlayersMaxMoves,
    _activePlayersNumMoves,
    _prevActivePlayers
  };
}
function ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, playerID, arg) {
  if (typeof arg !== "object" || arg === Stage.NULL) {
    arg = { stage: arg };
  }
  if (arg.stage !== void 0) {
    supportDeprecatedMoveLimit(arg);
    activePlayers[playerID] = arg.stage;
    if (arg.minMoves)
      _activePlayersMinMoves[playerID] = arg.minMoves;
    if (arg.maxMoves)
      _activePlayersMaxMoves[playerID] = arg.maxMoves;
  }
}
function getCurrentPlayer(playOrder, playOrderPos) {
  return playOrder[playOrderPos] + "";
}
function InitTurnOrderState(state, turn) {
  let { G: G2, ctx } = state;
  const { numPlayers } = ctx;
  const pluginAPIs = GetAPIs(state);
  const context = { ...pluginAPIs, G: G2, ctx };
  const order = turn.order;
  let playOrder = [...Array.from({ length: numPlayers })].map((_2, i2) => i2 + "");
  if (order.playOrder !== void 0) {
    playOrder = order.playOrder(context);
  }
  const playOrderPos = order.first(context);
  const posType = typeof playOrderPos;
  if (posType !== "number") {
    error(`invalid value returned by turn.order.first — expected number got ${posType} “${playOrderPos}”.`);
  }
  const currentPlayer = getCurrentPlayer(playOrder, playOrderPos);
  ctx = { ...ctx, currentPlayer, playOrderPos, playOrder };
  ctx = SetActivePlayers(ctx, turn.activePlayers || {});
  return ctx;
}
function UpdateTurnOrderState(state, currentPlayer, turn, endTurnArg) {
  const order = turn.order;
  let { G: G2, ctx } = state;
  let playOrderPos = ctx.playOrderPos;
  let endPhase = false;
  if (endTurnArg && endTurnArg !== true) {
    if (typeof endTurnArg !== "object") {
      error(`invalid argument to endTurn: ${endTurnArg}`);
    }
    Object.keys(endTurnArg).forEach((arg) => {
      switch (arg) {
        case "remove":
          currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);
          break;
        case "next":
          playOrderPos = ctx.playOrder.indexOf(endTurnArg.next);
          currentPlayer = endTurnArg.next;
          break;
        default:
          error(`invalid argument to endTurn: ${arg}`);
      }
    });
  } else {
    const pluginAPIs = GetAPIs(state);
    const context = { ...pluginAPIs, G: G2, ctx };
    const t2 = order.next(context);
    const type = typeof t2;
    if (t2 !== void 0 && type !== "number") {
      error(`invalid value returned by turn.order.next — expected number or undefined got ${type} “${t2}”.`);
    }
    if (t2 === void 0) {
      endPhase = true;
    } else {
      playOrderPos = t2;
      currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);
    }
  }
  ctx = {
    ...ctx,
    playOrderPos,
    currentPlayer
  };
  return { endPhase, ctx };
}
var TurnOrder = {
  /**
   * DEFAULT
   *
   * The default round-robin turn order.
   */
  DEFAULT: {
    first: ({ ctx }) => ctx.turn === 0 ? ctx.playOrderPos : (ctx.playOrderPos + 1) % ctx.playOrder.length,
    next: ({ ctx }) => (ctx.playOrderPos + 1) % ctx.playOrder.length
  },
  /**
   * RESET
   *
   * Similar to DEFAULT, but starts from 0 each time.
   */
  RESET: {
    first: () => 0,
    next: ({ ctx }) => (ctx.playOrderPos + 1) % ctx.playOrder.length
  },
  /**
   * CONTINUE
   *
   * Similar to DEFAULT, but starts with the player who ended the last phase.
   */
  CONTINUE: {
    first: ({ ctx }) => ctx.playOrderPos,
    next: ({ ctx }) => (ctx.playOrderPos + 1) % ctx.playOrder.length
  },
  /**
   * ONCE
   *
   * Another round-robin turn order, but goes around just once.
   * The phase ends after all players have played.
   */
  ONCE: {
    first: () => 0,
    next: ({ ctx }) => {
      if (ctx.playOrderPos < ctx.playOrder.length - 1) {
        return ctx.playOrderPos + 1;
      }
    }
  },
  /**
   * CUSTOM
   *
   * Identical to DEFAULT, but also sets playOrder at the
   * beginning of the phase.
   *
   * @param {Array} playOrder - The play order.
   */
  CUSTOM: (playOrder) => ({
    playOrder: () => playOrder,
    first: () => 0,
    next: ({ ctx }) => (ctx.playOrderPos + 1) % ctx.playOrder.length
  }),
  /**
   * CUSTOM_FROM
   *
   * Identical to DEFAULT, but also sets playOrder at the
   * beginning of the phase to a value specified by a field
   * in G.
   *
   * @param {string} playOrderField - Field in G.
   */
  CUSTOM_FROM: (playOrderField) => ({
    playOrder: ({ G: G2 }) => G2[playOrderField],
    first: () => 0,
    next: ({ ctx }) => (ctx.playOrderPos + 1) % ctx.playOrder.length
  })
};
var Stage = {
  NULL: null
};
var ActivePlayers = {
  /**
   * ALL
   *
   * The turn stays with one player, but any player can play (in any order)
   * until the phase ends.
   */
  ALL: { all: Stage.NULL },
  /**
   * ALL_ONCE
   *
   * The turn stays with one player, but any player can play (once, and in any order).
   * This is typically used in a phase where you want to elicit a response
   * from every player in the game.
   */
  ALL_ONCE: { all: Stage.NULL, minMoves: 1, maxMoves: 1 },
  /**
   * OTHERS
   *
   * The turn stays with one player, and every *other* player can play (in any order)
   * until the phase ends.
   */
  OTHERS: { others: Stage.NULL },
  /**
   * OTHERS_ONCE
   *
   * The turn stays with one player, and every *other* player can play (once, and in any order).
   * This is typically used in a phase where you want to elicit a response
   * from every *other* player in the game.
   */
  OTHERS_ONCE: { others: Stage.NULL, minMoves: 1, maxMoves: 1 }
};

export {
  alea,
  require_lodash,
  MAKE_MOVE,
  GAME_EVENT,
  REDO,
  RESET,
  SYNC,
  UNDO,
  UPDATE,
  PATCH,
  PLUGIN,
  STRIP_TRANSIENTS,
  makeMove,
  gameEvent,
  sync,
  patch,
  update,
  reset,
  undo,
  redo,
  stripTransients,
  ActionCreators,
  INVALID_MOVE,
  GameMethod,
  info,
  error,
  ProcessAction,
  GetAPIs,
  FnWrap,
  Setup,
  Enhance,
  NoClient,
  FlushAndValidate,
  PlayerView,
  supportDeprecatedMoveLimit,
  SetActivePlayers,
  UpdateActivePlayersOnceEmpty,
  InitTurnOrderState,
  UpdateTurnOrderState,
  TurnOrder,
  Stage,
  ActivePlayers
};
//# sourceMappingURL=chunk-FQIH6FHC.js.map
